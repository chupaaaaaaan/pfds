# Exercise 6.6

## (a)

`check` 関数内で遅延計算を生成しない場合、`checkw` 関数内で必要になった時点で遅延計算を生成かつ進行させる必要がある。
この場合、非共有コストが大きく、ポテンシャルの変化量が非共有コストを超えてしまう（銀行家法で言うと生成した負債を返済する機会がない）ため、償却コストの上限を壊してしまう。

- 上述の理由が正しいなら、必要な実コストは変わらないので、ポテンシャル関数をうまく定義すれば償却コストの上限を維持できるのではないか？（実用上は問題ないのではないか？）
- `checkw` 関数で `f` を `force` するコストは非共有コストとして計上済みだが、返済済みであることは保障されている？
- `w <- f'` と、`f <- $(f' @ List.rev r)` とで `f'` を評価するコストはそれぞれ必要という認識でよいか？

## (b)

`tail` で遅延計算を生成しない場合、`check` または `checkw` 内で要素を取り除く遅延計算を生成し、即座に進行させる必要がある。
(a)と同様、生成した負債を返済する機会がないため、償却コストの上限を壊してしまう。

- (a)と同様、実用上は問題ないのではないか？
